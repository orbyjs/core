{"version":3,"file":"orby.js","sources":["../src/vdom.js","../src/dom.js","../src/diff.js"],"sourcesContent":["export class VDom {\r\n    /**\r\n     *\r\n     * @param {Function|String} tag - Node component or label\r\n     * @param {Object} props - Properties of the label\r\n     * @param {Array} children - Children assigned to the node\r\n     */\r\n    constructor(tag, props = {}, children = []) {\r\n        this.tag = tag;\r\n        this.props = {\r\n            ...props,\r\n            children\r\n        };\r\n    }\r\n    /**\r\n     * Clone the current node by keeping props and children by default\r\n     * @param {Function|String} tag -  Node component or label\r\n     * @param {*} props - Properties of the label\r\n     * @param {*} children - Children assigned to the node\r\n     */\r\n    clone(tag = this.tag, props = this.props, children = this.props.children) {\r\n        return new VDom(tag, props, children);\r\n    }\r\n    /**\r\n     * Dispatch an existing function in `this.props`\r\n     * @param {String} prop - Property to emit the virtual node only if it exists as a function\r\n     * @param  {...any} args - Arguments to be issued to the function\r\n     */\r\n    emit(prop, ...args) {\r\n        if (this.prevent) return;\r\n        if (prop === \"remove\") this.prevent = true;\r\n        if (typeof this.props[prop] === \"function\") this.props[prop](...args);\r\n    }\r\n}\r\n/**\r\n * Prepare the virtual node\r\n * @param {Function|String} tag\r\n * @param {Object} props\r\n * @param  {...any} children\r\n * @return {VDom}\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return new VDom(tag || \"\", props, concat(children));\r\n}\r\n/**\r\n * Verify if this is a virtual node\r\n * @param {*} value\r\n * @return {Boolean}\r\n */\r\nexport function isVDom(value) {\r\n    return typeof value === \"object\" && value instanceof VDom;\r\n}\r\n/**\r\n * Clean existing values in virtual-dom tree\r\n * @param {*} children\r\n * @param {*} merge\r\n */\r\nexport function concat(children, merge = []) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        let child = children[i];\r\n        Array.isArray(child)\r\n            ? concat(child, merge)\r\n            : merge.push(\r\n                  isVDom(child) ? child : new VDom(\"\", {}, [child || \"\"])\r\n              );\r\n    }\r\n    return merge;\r\n}\r\n","export function create(tag, isSvg) {\r\n    return isSvg\r\n        ? document.createElementNS(\"http://www.w3.org/2000/svg\", tag)\r\n        : tag\r\n            ? document.createElement(tag)\r\n            : document.createTextNode(\"\");\r\n}\r\n\r\nexport function root(parent) {\r\n    return parent.shadowRoot || parent;\r\n}\r\nexport function remove(parent, child) {\r\n    root(parent).removeChild(child);\r\n}\r\n\r\nexport function append(parent, child) {\r\n    root(parent).appendChild(child);\r\n}\r\n\r\nexport function replace(parent, newChild, oldChild) {\r\n    root(parent).replaceChild(newChild, oldChild);\r\n}\r\n","import { VDom, isVDom } from \"./vdom\";\r\nimport { create, remove, append, replace } from \"./dom\";\r\nexport { h, VDom } from \"./vdom\";\r\n\r\n/**\r\n * Master is the mark to store the previous state\r\n * and if the node is controlled by one or more components\r\n */\r\nexport const MASTER = \"__master__\";\r\n/**\r\n * Each time a component is removed from the dom,\r\n * the property is marked as true\r\n */\r\nexport const REMOVE = \"__remove__\";\r\n/**\r\n * Special properties of virtual dom,\r\n * these are ignored from the diffProps process,\r\n * since it is part of the component's life cycle\r\n */\r\nexport const IGNORE = [\"children\", \"create\", \"remove\", \"context\", \"state\"];\r\n/**\r\n * It allows to print the status of virtual dom on the planned configuration\r\n * @param {VDom} next - the next state of the node\r\n * @param {HTMLElement} parent - the container of the node\r\n * @param {HTMLElement} [child]  - the ancestor of the node\r\n * @param {Object} [context] - the context of the node\r\n * @param {boolean} [isSvg] - check if the node belongs to a svg unit, to control it as such\r\n * @returns {HTMLElement} - The current node\r\n */\r\nexport function render(next, parent, child, context, isSvg) {\r\n    return diff(parent, child, next, context, isSvg);\r\n}\r\n/**\r\n * Gets the node's status mark\r\n * @param {HTMLElement} [base]\r\n * @return {object} - returns an object since the property associated\r\n *                    with the master in the whole diff is decomposed\r\n */\r\nexport function getMaster(base) {\r\n    return (base && base[MASTER]) || {};\r\n}\r\n/**\r\n *\r\n * @param {Function} component  - Function that controls the node\r\n * @param {*} [currentState] - The initial state of the component\r\n * @param {Boolean} [isSvg] - Create components for a group of svg\r\n * @return {HTMLElement} - Returns the current component node\r\n */\r\nexport function createComponent(component, currentState, isSvg) {\r\n    return function update(parent, base, props, context) {\r\n        return (base = render(\r\n            component(\r\n                props,\r\n                {\r\n                    /**\r\n                     * send a new status to update, to render the view\r\n                     * @param {*} - New state\r\n                     */\r\n                    set: state => {\r\n                        if (base[REMOVE]) return;\r\n                        currentState = state;\r\n                        base = update(parent, base, props, context);\r\n                    },\r\n                    get: () => currentState\r\n                },\r\n                context\r\n            ),\r\n            parent,\r\n            base,\r\n            context,\r\n            isSvg\r\n        ));\r\n    };\r\n}\r\n/**\r\n * It allows to print the status of virtual dom on the planned configuration\r\n * @param {HTMLElement} parent - the container of the node\r\n * @param {HTMLElement} [node]  - the ancestor of the node\r\n * @param {VDom} next - the next state of the node\r\n * @param {Object} [context] - the context of the node\r\n * @param {boolean} [isSvg] - check if the node belongs to a svg unit, to control it as such\r\n * @returns {HTMLElement} - The current node\r\n */\r\n\r\nexport function diff(parent, node, next, context = {}, isSvg) {\r\n    next = isVDom(next) ? next : new VDom(\"\", {}, [next || \"\"]);\r\n\r\n    let base = node,\r\n        { prev = new VDom(), components = new Map() } = getMaster(base),\r\n        component,\r\n        isCreate,\r\n        addContext = next.props.context;\r\n\r\n    context = addContext ? { ...context, ...addContext } : context;\r\n\r\n    isSvg = next.tag === \"svg\" || isSvg;\r\n\r\n    if (typeof next.tag === \"function\") {\r\n        component = next.tag;\r\n        if (!components.has(component)) {\r\n            components.set(\r\n                component,\r\n                createComponent(component, next.props.state, isSvg)\r\n            );\r\n        }\r\n        next = next.clone(prev.tag || (isSvg ? \"g\" : \"\"));\r\n    }\r\n\r\n    let children = next.props.children;\r\n\r\n    if (next.tag !== prev.tag) {\r\n        base = create(next.tag, isSvg);\r\n        if (node) {\r\n            if (!component && next.tag !== \"\") {\r\n                let length = children.length;\r\n                while (node.firstChild) {\r\n                    if (!length--) break;\r\n                    append(base, node.firstChild);\r\n                }\r\n            }\r\n            replace(parent, base, node);\r\n            emitRemove(node);\r\n        } else {\r\n            append(parent, base);\r\n        }\r\n        isCreate = true;\r\n        next.emit(\"create\", base);\r\n    }\r\n    if (component && components.has(component)) {\r\n        return components.get(component)(parent, base, next.props, context);\r\n    } else if (!next.tag) {\r\n        if (prev.props.children[0] !== next.props.children[0]) {\r\n            base.textContent = next.props.children[0];\r\n        }\r\n    } else {\r\n        if (isCreate || next.emit(\"update\", next.props, base) !== false) {\r\n            diffProps(base, prev.props, next.props, isSvg);\r\n            let childNodes = Array.from(base.childNodes),\r\n                length = Math.max(childNodes.length, children.length);\r\n            for (let i = 0; i < length; i++) {\r\n                if (children[i]) {\r\n                    diff(base, childNodes[i], children[i], context, isSvg);\r\n                } else {\r\n                    if (childNodes[i]) {\r\n                        emitRemove(childNodes[i]);\r\n                        remove(base, childNodes[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    base[MASTER] = {\r\n        prev: component ? getMaster(base).prev : next,\r\n        components\r\n    };\r\n\r\n    next.emit(isCreate ? \"created\" : \"updated\", base);\r\n\r\n    return base;\r\n}\r\n/**\r\n * Update or delete the attributes and events of a node\r\n * @param {HTMLElement} node - Node to assign changes\r\n * @param {Object} prev - Previous status of attributes\r\n * @param {Object} next - next status of attributes\r\n * @param {Boolean} [isSvg] - If it belongs to svg tree\r\n */\r\nexport function diffProps(node, prev, next, isSvg) {\r\n    let prevKeys = Object.keys(prev),\r\n        nextKeys = Object.keys(next).filter(\r\n            key => prevKeys.indexOf(key) === -1\r\n        ),\r\n        keys = prevKeys.concat(nextKeys);\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n        let prop = keys[i];\r\n\r\n        if (prev[prop] === next[prop] || IGNORE.indexOf(prop) > -1) continue;\r\n\r\n        let isFnPrev = typeof prev[prop] === \"function\",\r\n            isFnNext = typeof next[prop] === \"function\";\r\n\r\n        if (isFnPrev || isFnNext) {\r\n            if (isFnPrev) node.removeEventListener(prop, prev[prop]);\r\n            if (isFnNext) node.addEventListener(prop, next[prop]);\r\n        } else if (prop in next) {\r\n            if ((prop in node && !isSvg) || (isSvg && prop === \"style\")) {\r\n                if (prop === \"style\") {\r\n                    if (typeof next[prop] === \"object\") {\r\n                        let prevStyle = prev[prop] || {},\r\n                            nextStyle = next[prop];\r\n                        for (let prop in nextStyle) {\r\n                            if (prevStyle[prop] !== nextStyle[prop]) {\r\n                                if (prop[0] === \"-\") {\r\n                                    node.setProperty(prop, nextStyle[prop]);\r\n                                } else {\r\n                                    node.style[prop] = nextStyle[prop];\r\n                                }\r\n                            }\r\n                        }\r\n                        next[prop] = { ...prevStyle, ...nextStyle };\r\n                    } else {\r\n                        node.style.cssText = next[prop];\r\n                    }\r\n                } else {\r\n                    node[prop] = next[prop];\r\n                }\r\n            } else {\r\n                isSvg\r\n                    ? node.setAttributeNS(null, prop, next[prop])\r\n                    : node.setAttribute(prop, next[prop]);\r\n            }\r\n        } else {\r\n            node.removeAttribute(prop);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Issues the deletion of node and its children\r\n * @param {HTMLElement} base\r\n */\r\nexport function emitRemove(base) {\r\n    let { prev = new VDom() } = getMaster(base),\r\n        children = base.childNodes;\r\n    base[REMOVE] = true;\r\n    prev.emit(\"remove\", base);\r\n    for (let i = 0; i < children.length; i++) {\r\n        emitRemove(children[i]);\r\n    }\r\n    prev.emit(\"removed\", base);\r\n}\r\n"],"names":["VDom","constructor","tag","props","children","clone","this","emit","prop","args","prevent","h","concat","isVDom","value","merge","i","length","child","Array","isArray","push","create","isSvg","document","createElementNS","createElement","createTextNode","root","parent","shadowRoot","remove","removeChild","append","appendChild","replace","newChild","oldChild","replaceChild","MASTER","REMOVE","IGNORE","render","next","context","diff","getMaster","base","createComponent","component","currentState","update","set","state","get","node","isCreate","prev","components","Map","addContext","has","firstChild","emitRemove","diffProps","childNodes","from","Math","max","textContent","prevKeys","Object","keys","nextKeys","filter","key","indexOf","isFnPrev","isFnNext","removeEventListener","addEventListener","prevStyle","nextStyle","setProperty","style","cssText","setAttributeNS","setAttribute","removeAttribute"],"mappings":"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"}